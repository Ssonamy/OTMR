#pragma config(Sensor, S2, sonarSensor, sensorSONAR)
#pragma config(Sensor, S3, colorSensorF, sensorLightActive)
#pragma config(Sensor, S1, colorSensorB, sensorLightActive)
#pragma config(Motor,  motorB, rightMotor, tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC, leftMotor,  tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

task main()
{
    // Индивидуальные пороги
    const int reflectThresholdF = 56;   // перед
    const int reflectThresholdB = 38;   // зад

    const int speed = 90;
    const int turnSpeed = 70;
    const int enemyDistance = 40;

    long startTime = nSysTime;

    while (nSysTime - startTime < 60000)
    {
        int frontLight = SensorValue[colorSensorF];
        int backLight  = SensorValue[colorSensorB];
        int distance   = SensorValue[sonarSensor];

        /* ===== ПРИОРИТЕТ 1: ЗАДНЯЯ ЛИНИЯ ===== */
        if (backLight <= reflectThresholdB)
        {
            // Немедленно возвращаемся в ринг
            setMotorSpeed(leftMotor, speed);
            setMotorSpeed(rightMotor, speed);
            wait1Msec(60);
            continue;
        }

        /* ===== ПРИОРИТЕТ 2: ПЕРЕДНЯЯ ЛИНИЯ ===== */
        if (frontLight <= reflectThresholdF)
        {
            // Уход назад
            setMotorSpeed(leftMotor, -speed);
            setMotorSpeed(rightMotor, -speed);
            wait1Msec(300);

            // Разворот
            setMotorSpeed(leftMotor, turnSpeed);
            setMotorSpeed(rightMotor, -turnSpeed);
            wait1Msec(600);
            continue;
        }

        /* ===== ПОИСК / АТАКА ===== */
        if (distance > 0 && distance < enemyDistance)
        {
            // Противник найден — атака
            setMotorSpeed(leftMotor, speed);
            setMotorSpeed(rightMotor, speed);
        }
        else
        {
            // Противник не найден — поиск
            setMotorSpeed(leftMotor, turnSpeed);
            setMotorSpeed(rightMotor, -turnSpeed);
        }

        wait1Msec(20);
    }

    // Остановка по завершении времени
    setMotorSpeed(leftMotor, 0);
    setMotorSpeed(rightMotor, 0);
}
