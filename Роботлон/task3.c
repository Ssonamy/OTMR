#pragma config(Sensor, S3,     leftLight,      sensorLightActive)
#pragma config(Sensor, S4,     rightLight,     sensorLightActive)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int BASE_SPEED = 58;        // ½àçîâà¤ ñêîðîñòü
const float TURN_GAIN = 3.5;      // çåçêîñòü ïîâîðîòà
const int TARGET = 50;            // öåëåâîå çíà÷åíèå äàò÷èêà (ìàêñ + ìèí)/2
const int TOLERANCE = 20;         // ïîãðåøíîñòü
const int SEARCH_SPEED = 25;      // ñêîðîñòü ïîèñêà
const int SEARCH_TIME = 800;      // âðåì¤ ïîèñêà
int DIR = 1;                      // èçíà÷àëüíîå íàïðàâëåíèå ïîèñêà

const int TIME_1 = 6000;
const int TIME_2 = 19000;
const int TIME_3 = 20500;
const int TIME_4 = 36500;
const int Time_0 = 40500;


void aRotation(int dir = 1, int startPos= 90){
    nMotorEncoder[armMotor] = 0;

    int target = 180- startPos;

    while(abs(nMotorEncoder[armMotor]) < target)
    {
        motor[armMotor] = 10 * dir;
    }

    motor[armMotor] = 0;
}


bool onLine() {
	int L = SensorValue[leftLight];
	int R = SensorValue[rightLight];
	return (L < TARGET + TOLERANCE || R < TARGET + TOLERANCE);
}

void stopMotors() {
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
	wait1Msec(100);
}


void rotationUntilLine(int dir) {
	while (true) {
		setMotorSpeed(leftMotor, SEARCH_SPEED * dir);
		setMotorSpeed(rightMotor, -SEARCH_SPEED * dir);
		wait1Msec(SEARCH_TIME);

		if (onLine()) {
			stopMotors();
			return;
		}

		// ???±N??°N???N??? ????????N???N?
		setMotorSpeed(leftMotor, -SEARCH_SPEED * dir);
		setMotorSpeed(rightMotor, SEARCH_SPEED * dir);
		wait1Msec(SEARCH_TIME / 2);

		if (onLine()) {
			stopMotors();
			return;
		}
	}
}

void followLine() {
	while (true) {
		int leftVal = SensorValue[leftLight];
		int rightVal = SensorValue[rightLight];

		int error = leftVal - rightVal;

		int leftPower = BASE_SPEED - TURN_GAIN * error;
		int rightPower = BASE_SPEED + TURN_GAIN * error;

		setMotorSpeed(leftMotor, leftPower);
		setMotorSpeed(rightMotor, rightPower);

		if (leftVal > TARGET + TOLERANCE && rightVal > TARGET + TOLERANCE) {
			stopMotors();
			break;
		}

		wait1Msec(10);
	}
}

task TimerTask(){
	clearTimer(T1); // Îò÷èñòêà òàéìåðà

	while (true){
		int currentTime = time1[T1];
		if (currentTime >= TIME_1){
			aRotation(1, 90);
			break;
		}
	}
	
	while (true){
		int currentTime = time1[T1];
		if (currentTime >= TIME_2){
			aRotation(-1, 0);
			break;
		}
	}
	while (true){
		int currentTime = time1[T1];
		if (currentTime >= TIME_3){
			aRotation(1, 0);
			break;
		}
	}
	
	while (true){
		int currentTime = time1[T1];
		if (currentTime >= TIME_4){
			aRotation(-1, 0);
			break;
		}
	}
	while (true){
		int currentTime = time1[T1];
		if (currentTime >= Time_0){
			aRotation(1, 90);
			stopAllTasks();
		}
	}
}

task main() {
	startTask(TimerTask);
	if (!onLine()) {
		rotationUntilLine(DIR);
	}

	while (true) {
		followLine();

		rotationUntilLine(DIR);
	}
}
