#pragma config(Sensor, S1,     lightRight,     sensorLightActive)
#pragma config(Sensor, S2,     gyro,           sensorAnalog)
#pragma config(Sensor, S3,     sonarSensor,          sensorSONAR)
#pragma config(Sensor, S4,     lightLeft,      sensorLightActive)
#pragma config(Motor,  motorB, leftMotor, tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC, rightMotor, tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Код написан под робота lego rembot dualLight

task stream(){
	while (true){
	writeDebugStreamLine("time: %d мс", time1[T1]);
	}
}

task main(){
	startTask (stream);
	
	int baseSpeed = 50;    	// базовая скорость моторов
    int Kp = 2;             // коэффициент пропорциональности

	int duration1 = 10700; 	// при скорости движения по линии в 50
	int duration2 = 27000;
	int duration3 = 20500;		
	
	// Изначальный поворот
	motor[motorB] =  30; 
	motor[motorC] = -30;
	wait10Msec(220);
	
	// Доезд до линии		
	motor[motorB] = 50;   	// скорость левого мотора
	motor[motorC] = 50;   	// скорость правого мотора
	while(SensorValue[sonarSensor] > 25){}
	
	// Поворот по направлению линии
	motor[motorB] =  30; 
	motor[motorC] = -30;
	wait10Msec(100);
	
	clearTimer(T1);
	
	// Перва езда по линии
	while(time1[T1] < duration1){
		int leftVal = SensorValue[lightLeft];   // считываем левый датчик
		int rightVal = SensorValue[lightRight]; // считываем правый датчик

		int error = leftVal - rightVal;         // ошибка положения относительно линии

		// вычисляем скорость моторов с пропорциональной корректировкой
		motor[leftMotor]  = baseSpeed - Kp * error;
		motor[rightMotor] = baseSpeed + Kp * error;
	}
	
	// Переезд трамплина
	motor[motorB] = 50;   	// скорость левого мотора
	motor[motorC] = 50;   	// скорость правого мотора
	wait10Msec (840);
	
	// Поворот по направлению линии
	motor[motorB] = -30; 
	motor[motorC] =  30;
	wait10Msec(115);

	motor[motorB] = 50;   	// скорость левого мотора
	motor[motorC] = 50;   	// скорость правого мотора
	wait10Msec(100);
	
	clearTimer(T1);
	
	while(time1[T1] < duration2)
		{
			int leftVal = SensorValue[lightLeft];   // считываем левый датчик
			int rightVal = SensorValue[lightRight]; // считываем правый датчик

			int error = leftVal - rightVal;         // ошибка положения относительно линии

			// вычисляем скорость моторов с пропорциональной корректировкой
			motor[leftMotor]  = baseSpeed - Kp * error;
			motor[rightMotor] = baseSpeed + Kp * error;
		}
		
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait10Msec(280);
	
	motor[motorB] = -30; 
	motor[motorC] =  30;
	wait10Msec(110);
	
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait10Msec(150);

	motor[motorB] = 30; 
	motor[motorC] = -30;
	wait10Msec(110);
	
	motor[motorB] = 50;
	motor[motorC] = 50;
	while(SensorValue[sonarSensor] > 45){}
	
	motor[motorB] = 30; 
	motor[motorC] = -30;
	wait10Msec(100);
	
	clearTimer(T1);
	
	while(time1[T1] < duration3)
	{
		int leftVal = SensorValue[lightLeft];   // считываем левый датчик
		int rightVal = SensorValue[lightRight]; // считываем правый датчик

		int error = leftVal - rightVal;         // ошибка положения относительно линии

		// вычисляем скорость моторов с пропорциональной корректировкой
		motor[leftMotor]  = baseSpeed - Kp * error;
		motor[rightMotor] = baseSpeed + Kp * error;
	}
	
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait10Msec(570);
	
	motor[motorB] = -30; 
	motor[motorC] =  30;
	wait10Msec(110);
	
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait10Msec(100);
	
	while(true)
	{
		int leftVal = SensorValue[lightLeft];   // считываем левый датчик
		int rightVal = SensorValue[lightRight]; // считываем правый датчик

		int error = leftVal - rightVal;         // ошибка положения относительно линии

		// вычисляем скорость моторов с пропорциональной корректировкой
		motor[leftMotor]  = baseSpeed - Kp * error;
		motor[rightMotor] = baseSpeed + Kp * error;
	}
}