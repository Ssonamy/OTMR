#pragma config(Sensor, S1,     lightRight,     sensorLightActive)
#pragma config(Sensor, S2,     gyro,           sensorAnalog)
#pragma config(Sensor, S3,     sonarSensor,          sensorSONAR)
#pragma config(Sensor, S4,     lightLeft,      sensorLightActive)
#pragma config(Motor,  motorB, leftMotor, tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC, rightMotor, tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Код написан под робота lego rembot dualLight
task stream(){
	while (true){
	writeDebugStreamLine("time: %d мс", time1[T1]);
	}
}


task main(){
	startTask (stream);
	
	int baseSpeed = 50;      // базовая скорость моторов
    int Kp = 2;              // коэффициент пропорциональности

	int duration1 = 28500; // при скорости движения по линии в 50
	int duration2 = 19000;
	int duration3 = 21500;		
	
	int duration1r = 21500; // при скорости движения по линии в 50
	int duration2r = 16500;
	int duration3r = 28300;
	
	if (SensorValue[sonarSensor] > 100){


		while(SensorValue[sonarSensor] > 25 || SensorValue[sonarSensor] == -1) // -1 если ничего не видно
		{
			motor[motorB] = 50;    // скорость левого мотора
			motor[motorC] = 50;   // скорость правого мотора
		}

		// Остановка моторов, когда расстояние <= 25 см
		motor[motorB] = 0;
		motor[motorC] = 0;
		wait10Msec(5);
		
		motor[motorB] = -30;
		motor[motorC] =  30;
		wait10Msec(50);
		
		clearTimer(T1);
		
		while(time1[T1] < duration1)
		{
			int leftVal = SensorValue[lightLeft];   // считываем левый датчик
			int rightVal = SensorValue[lightRight]; // считываем правый датчик

			int error = leftVal - rightVal;         // ошибка положения относительно линии

			// вычисляем скорость моторов с пропорциональной корректировкой
			motor[leftMotor]  = baseSpeed - Kp * error;
			motor[rightMotor] = baseSpeed + Kp * error;
		}
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		wait10Msec (240);
		
		clearTimer(T1);
		
		while(time1[T1] < duration2)
		{
			int leftVal = SensorValue[lightLeft];   // считываем левый датчик
			int rightVal = SensorValue[lightRight]; // считываем правый датчик

			int error = leftVal - rightVal;         // ошибка положения относительно линии

			// вычисляем скорость моторов с пропорциональной корректировкой
			motor[leftMotor]  = baseSpeed - Kp * error;
			motor[rightMotor] = baseSpeed + Kp * error;
		}
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		wait10Msec (400);
		
		motor[motorB] = -30;
		motor[motorC] =  30;
		wait10Msec(120);
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		wait10Msec (100);
		
		clearTimer(T1);
		
		while(time1[T1] < duration3)
		{
			int leftVal = SensorValue[lightLeft];   // считываем левый датчик
			int rightVal = SensorValue[lightRight]; // считываем правый датчик

			int error = leftVal - rightVal;         // ошибка положения относительно линии

			// вычисляем скорость моторов с пропорциональной корректировкой
			motor[leftMotor]  = baseSpeed - Kp * error;
			motor[rightMotor] = baseSpeed + Kp * error;
		}
		motor[motorB] = -30;
		motor[motorC] =  30;
		wait10Msec(120);
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		wait10Msec (430);
	}

	else {
		// Изначальный поворот
		motor[motorB] =  30; 
		motor[motorC] = -30;
		wait10Msec(110);
		
		// Доезд до линии
		while(SensorValue[sonarSensor] > 25 || SensorValue[sonarSensor] == -1) // -1 если ничего не видно
		{
			motor[motorB] = 70;    // скорость левого мотора
			motor[motorC] = 70;   // скорость правого мотора
		}
		
		// Остановка моторов
		motor[motorB] = 0;
		motor[motorC] = 0;
		wait10Msec(5);
		
		// Поворот по направлению к линии
		motor[motorB] =  30;
		motor[motorC] = -30;
		wait10Msec(50);
		
		clearTimer(T1);
		
		// Езда по линии
		while(time1[T1] < duration1r)
		{
			int leftVal = SensorValue[lightLeft];   // считываем левый датчик
			int rightVal = SensorValue[lightRight]; // считываем правый датчик

			int error = leftVal - rightVal;         // ошибка положения относительно линии

			// вычисляем скорость моторов с пропорциональной корректировкой
			motor[leftMotor]  = baseSpeed - Kp * error;
			motor[rightMotor] = baseSpeed + Kp * error;
		}
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		wait10Msec (88);
		
		motor[motorB] =  30;
		motor[motorC] = -30;
		wait10Msec(100);
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		wait10Msec (550);
		
		clearTimer(T1);
		
		while(time1[T1] < duration2r)
		{
			int leftVal = SensorValue[lightLeft];   // считываем левый датчик
			int rightVal = SensorValue[lightRight]; // считываем правый датчик

			int error = leftVal - rightVal;         // ошибка положения относительно линии

			// вычисляем скорость моторов с пропорциональной корректировкой
			motor[leftMotor]  = baseSpeed - Kp * error;
			motor[rightMotor] = baseSpeed + Kp * error;
		}
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		wait10Msec (230);
		
		clearTimer(T1);
		
		while(time1[T1] < duration3r)
		{
			int leftVal = SensorValue[lightLeft];   // считываем левый датчик
			int rightVal = SensorValue[lightRight]; // считываем правый датчик

			int error = leftVal - rightVal;         // ошибка положения относительно линии

			// вычисляем скорость моторов с пропорциональной корректировкой
			motor[leftMotor]  = baseSpeed - Kp * error;
			motor[rightMotor] = baseSpeed + Kp * error;
		}
		motor[motorB] =  30;
		motor[motorC] = -30;
		wait10Msec(110);
		
		motor[motorB] = 50;
		motor[motorC] = 50;
		wait10Msec (400);
	}
}