#pragma config(Sensor, S1,     lightRight,     sensorLightActive)
#pragma config(Sensor, S2,     gyro,           sensorAnalog)
#pragma config(Sensor, S3,     sonarSensor,          sensorSONAR)
#pragma config(Sensor, S4,     lightLeft,      sensorLightActive)
#pragma config(Motor,  motorB, leftMotor, tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC, rightMotor, tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Код написан под робота lego rembot dualLight

task stream(){
	while (true){
	writeDebugStreamLine("time: %d мс", time1[T1]);
	}
}

task main(){
	startTask (stream);
	
	int baseSpeed = 50;    	// базовая скорость моторов
    int Kp = 2;             // коэффициент пропорциональности

	int duration1 = 8500; 	// при скорости движения по линии в 50
	int duration2 = 20500;
	int duration3 = 29000;		
	int duration4 = 11200;		
	
	// Изначальный поворот
	motor[motorB] =  30; 
	motor[motorC] = -30;
	wait10Msec(109);
	
	// Доезд до линии		
	motor[motorB] = 50;   	// скорость левого мотора
	motor[motorC] = 50;   	// скорость правого мотора
	while(SensorValue[sonarSensor] > 20){}
		
	// Поворот по направлению линии
	motor[motorB] =  30; 
	motor[motorC] = -30;
	wait10Msec(100);
	
	clearTimer(T1);
	
	// Перва езда по линии
	while(time1[T1] < duration1){
		int leftVal = SensorValue[lightLeft];   // считываем левый датчик
		int rightVal = SensorValue[lightRight]; // считываем правый датчик

		int error = leftVal - rightVal;         // ошибка положения относительно линии

		// вычисляем скорость моторов с пропорциональной корректировкой
		motor[leftMotor]  = baseSpeed - Kp * error;
		motor[rightMotor] = baseSpeed + Kp * error;
	}
	
	// Движение вперед перед поворотом
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait10Msec(125);
	
	//Поворот к трамплину к линии
	motor[motorB] =  30; 
	motor[motorC] = -30;
	wait10Msec(103);
	
	// Доезд до линии
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait10Msec(560);
	
	// Второе движение по линии
	clearTimer(T1);
	while(time1[T1] < duration2){
		int leftVal = SensorValue[lightLeft];   // считываем левый датчик
		int rightVal = SensorValue[lightRight]; // считываем правый датчик

		int error = leftVal - rightVal;         // ошибка положения относительно линии

		// вычисляем скорость моторов с пропорциональной корректировкой
		motor[leftMotor]  = baseSpeed - Kp * error;
		motor[rightMotor] = baseSpeed + Kp * error;
	}
	
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait10Msec(100);
	
	motor[motorB] = -30; 
	motor[motorC] =  30;
	wait10Msec(110);
	
	// 
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait10Msec(350);

	motor[motorB] = -30; 
	motor[motorC] =  30;
	wait10Msec(110);
	
	motor[motorB] = 50; 
	motor[motorC] = 50;
	wait10Msec(150);
	
	motor[motorB] =  30; 
	motor[motorC] = -30;
	wait10Msec(110);
	/// summary ///
	// Объезд конуса и подъезд к линии
	
	// Третья езда по линии
	clearTimer(T1);
	while(time1[T1] < duration3){
		int leftVal = SensorValue[lightLeft];   // считываем левый датчик
		int rightVal = SensorValue[lightRight]; // считываем правый датчик

		int error = leftVal - rightVal;         // ошибка положения относительно линии

		// вычисляем скорость моторов с пропорциональной корректировкой
		motor[leftMotor]  = baseSpeed - Kp * error;
		motor[rightMotor] = baseSpeed + Kp * error;
	}
	
	// Подъезл к трамплину
	motor[motorB] = 50; 
	motor[motorC] = 50;
	wait10Msec(95);
	
	// Поворот к трамплину
	motor[motorB] =  30; 
	motor[motorC] = -30;
	wait10Msec(105);
	
	// Проезд трамплина
	motor[motorB] = 50; 
	motor[motorC] = 50;
	wait10Msec(800);
	
	// Четвертая езда по линии
	clearTimer(T1);
	while(time1[T1] < duration4){
		int leftVal = SensorValue[lightLeft];   // считываем левый датчик
		int rightVal = SensorValue[lightRight]; // считываем правый датчик

		int error = leftVal - rightVal;         // ошибка положения относительно линии

		// вычисляем скорость моторов с пропорциональной корректировкой
		motor[leftMotor]  = baseSpeed - Kp * error;
		motor[rightMotor] = baseSpeed + Kp * error;
	}
	
	// Поворот к финишу
	motor[motorB] = -30; 
	motor[motorC] =  30;
	wait10Msec(110);
	
	// Доезд до финиша
	motor[motorB] = 50; 
	motor[motorC] = 50;
	wait10Msec(500);
}