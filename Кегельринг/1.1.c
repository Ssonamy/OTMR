#pragma config(Sensor, S3,     lightSensor,    sensorEV3_Color)
#pragma config(Sensor, S2,     sonarRight,     sensorEV3_IRSensor)
#pragma config(Sensor, S4,     sonarLeft,      sensorEV3_IRSensor)
#pragma config(Motor,  motorB,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

const int speedSearch = 35;
const int speedAlign  = 20;
const int speedPush   = 45;

// 33 - w; 3 - b

const int sonarDetect = 45;
const int reflectThreshold = 18;
const int totalBanks = 8;

void stopMotors()
{
    motor[leftMotor]  = 0;
    motor[rightMotor] = 0;
    wait1Msec(50);
}

task main()
{
    int bankCount = 0;

    while(bankCount < totalBanks)
    {
        /* ===== ПОИСК: ВСЕГДА КРУТИМСЯ ===== */
        while(true)
        {
            motor[leftMotor]  =  speedSearch;
            motor[rightMotor] = -speedSearch;

            int dL = SensorValue[sonarLeft];
            int dR = SensorValue[sonarRight];

            // игнорируем нули
            if( (dL > 0 && dL < sonarDetect) ||
                (dR > 0 && dR < sonarDetect) )
                break;

            wait1Msec(20);
        }

        stopMotors();

        /* ===== ДОВОРОТ ===== */
        clearTimer(T1);
        while(time1[T1] < 150)
        {
            int dL = SensorValue[sonarLeft];
            int dR = SensorValue[sonarRight];

            if(dL > 0 && dR > 0 && abs(dL - dR) < 3)
                break;

            if(dL == 0 || dR == 0)
                continue;

            if(dL < dR)
            {
                motor[leftMotor]  =  speedAlign;
                motor[rightMotor] = -speedAlign;
            }
            else
            {
                motor[leftMotor]  = -speedAlign;
                motor[rightMotor] =  speedAlign;
            }
        }

        stopMotors();

        /* ===== ТОЛКАНИЕ ДО ЛИНИИ ===== */
        resetMotorEncoder(leftMotor);

        while(SensorValue[lightSensor] > reflectThreshold)
        {
            motor[leftMotor]  = speedPush;
            motor[rightMotor] = speedPush;
        }

        stopMotors();

        int forwardTicks = abs(getMotorEncoder(leftMotor));

        /* ===== ВОЗВРАТ ===== */
        resetMotorEncoder(leftMotor);

        while(abs(getMotorEncoder(leftMotor)) < forwardTicks)
        {
            motor[leftMotor]  = -speedPush;
            motor[rightMotor] = -speedPush;
        }

        stopMotors();
        bankCount++;
        wait1Msec(150);
    }

    stopMotors();
}
